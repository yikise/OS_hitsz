diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..229775a
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,5 @@
+{
+    "files.associations": {
+        "riscv.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/kernel/bio.c b/kernel/bio.c
index 60d91a6..63d24cc 100644
--- a/kernel/bio.c
+++ b/kernel/bio.c
@@ -22,33 +22,40 @@
 #include "defs.h"
 #include "fs.h"
 #include "buf.h"
-
+#define NBUCKETS 13
 struct {
-  struct spinlock lock;
+  struct spinlock global_lock;
+  struct spinlock lock[NBUCKETS];
   struct buf buf[NBUF];
 
   // Linked list of all buffers, through prev/next.
   // Sorted by how recently the buffer was used.
   // head.next is most recent, head.prev is least.
-  struct buf head;
+  //struct buf head;
+  struct buf hashbucket[NBUCKETS]; //每个哈希队列一个linked list及一个lock
 } bcache;
 
 void
 binit(void)
 {
   struct buf *b;
-
-  initlock(&bcache.lock, "bcache");
+  initlock(&bcache.global_lock, "bcache_global");
+  //初始化hashbucket
+  for(int i = 0; i < NBUCKETS; i++) {
+    initlock(&bcache.lock[i], "bcache");
+    bcache.hashbucket[i].prev = &bcache.hashbucket[i];
+    bcache.hashbucket[i].next = &bcache.hashbucket[i];
+}
 
   // Create linked list of buffers
-  bcache.head.prev = &bcache.head;
-  bcache.head.next = &bcache.head;
-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
+  //初始化buffer
+  for (b = bcache.buf; b < bcache.buf+NBUF; b++) {
+    int hashNumber = b->blockno % NBUCKETS;
+    b->next = bcache.hashbucket[hashNumber].next;
+    b->prev = &bcache.hashbucket[hashNumber];
     initsleeplock(&b->lock, "buffer");
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
+    bcache.hashbucket[hashNumber].next->prev = b;
+    bcache.hashbucket[hashNumber].next = b;
   }
 }
 
@@ -59,32 +66,83 @@ static struct buf*
 bget(uint dev, uint blockno)
 {
   struct buf *b;
-
-  acquire(&bcache.lock);
+  //Hash(blockno)的过程
+  int hashNumber = blockno % NBUCKETS;
+  acquire(&bcache.lock[hashNumber]);
 
   // Is the block already cached?
-  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+  for(b = bcache.hashbucket[hashNumber].next; b != &bcache.hashbucket[hashNumber]; b = b->next){
     if(b->dev == dev && b->blockno == blockno){
       b->refcnt++;
-      release(&bcache.lock);
+      release(&bcache.lock[hashNumber]);
       acquiresleep(&b->lock);
       return b;
     }
   }
 
-  // Not cached.
-  // Recycle the least recently used (LRU) unused buffer.
-  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+  for(b = bcache.hashbucket[hashNumber].prev; b != &bcache.hashbucket[hashNumber]; b = b->prev) {
     if(b->refcnt == 0) {
       b->dev = dev;
       b->blockno = blockno;
       b->valid = 0;
       b->refcnt = 1;
-      release(&bcache.lock);
+      release(&bcache.lock[hashNumber]);
       acquiresleep(&b->lock);
       return b;
     }
   }
+
+  // Not cached.
+  
+  //首先释放原先哈希桶的锁
+  release(&bcache.lock[hashNumber]);
+
+  //获取全局锁
+  acquire(&bcache.global_lock);
+
+  //获取哈希桶的锁
+  acquire(&bcache.lock[hashNumber]);
+
+  // Recycle the least recently used (LRU) unused buffer.
+  //循环遍历NBUCKETS个哈希桶
+  for (int i = 0; i < NBUCKETS; i++) {
+    //获取当前哈希桶的锁
+    if (i != hashNumber) {
+      acquire(&bcache.lock[i]);
+    }
+    for(b = bcache.hashbucket[i].prev; b != &bcache.hashbucket[i]; b = b->prev){
+      if(b->refcnt == 0) {
+        //若当前哈希桶不是原先哈希桶，
+        //则需要把搜索到的空闲buffer移到我们原先的哈希桶中
+        if(i != hashNumber) {
+          b->next->prev = b->prev;
+          b->prev->next = b->next;
+          //释放该哈希桶的锁
+          release(&bcache.lock[i]);
+          b->next = bcache.hashbucket[hashNumber].next;
+          b->prev = &bcache.hashbucket[hashNumber];
+          bcache.hashbucket[hashNumber].next->prev = b;
+          bcache.hashbucket[hashNumber].next = b;
+        }
+        b->dev = dev;
+        b->blockno = blockno;
+        b->valid = 0;
+        b->refcnt = 1;
+        
+        release(&bcache.lock[hashNumber]);
+        release(&bcache.global_lock); //释放全局锁
+
+        acquiresleep(&b->lock);
+        return b;
+      }
+    }
+    if (i != hashNumber) {
+      release(&bcache.lock[i]);
+    }
+  }
+  release(&bcache.lock[hashNumber]);
+  release(&bcache.global_lock); //释放全局锁
+
   panic("bget: no buffers");
 }
 
@@ -121,33 +179,38 @@ brelse(struct buf *b)
 
   releasesleep(&b->lock);
 
-  acquire(&bcache.lock);
+  //获取hashNumber
+  int hashNumber = b->blockno % NBUCKETS;
+  //获取当前哈希桶的锁
+  acquire(&bcache.lock[hashNumber]);
   b->refcnt--;
   if (b->refcnt == 0) {
     // no one is waiting for it.
     b->next->prev = b->prev;
     b->prev->next = b->next;
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
+
+    b->next = bcache.hashbucket[hashNumber].next;
+    b->prev = &bcache.hashbucket[hashNumber];
+    bcache.hashbucket[hashNumber].next->prev = b;
+    bcache.hashbucket[hashNumber].next = b;
   }
-  
-  release(&bcache.lock);
+  release(&bcache.lock[hashNumber]);
 }
 
 void
 bpin(struct buf *b) {
-  acquire(&bcache.lock);
+  //获取hashNumber
+  int hashNumber = b->blockno % NBUCKETS;
+  acquire(&bcache.lock[hashNumber]);
   b->refcnt++;
-  release(&bcache.lock);
+  release(&bcache.lock[hashNumber]);
 }
 
 void
 bunpin(struct buf *b) {
-  acquire(&bcache.lock);
+  //获取hashNumber
+  int hashNumber = b->blockno % NBUCKETS;
+  acquire(&bcache.lock[hashNumber]);
   b->refcnt--;
-  release(&bcache.lock);
-}
-
-
+  release(&bcache.lock[hashNumber]);
+}
\ No newline at end of file
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index fa6a0ac..e2c37a5 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -18,15 +18,22 @@ struct run {
   struct run *next;
 };
 
-struct {
+struct kmem{
   struct spinlock lock;
   struct run *freelist;
-} kmem;
+};
+struct kmem kmems[NCPU];
 
 void
 kinit()
 {
-  initlock(&kmem.lock, "kmem");
+  for(int i = 0; i < NCPU; i++) {
+    //使锁名字以kmem开头
+    // char name[10];
+    // snprintf(name, sizeof(name), "kmem%d", i);
+    //初始化锁
+    initlock(&kmems[i].lock, "kmem*");
+  }
   freerange(end, (void*)PHYSTOP);
 }
 
@@ -56,10 +63,16 @@ kfree(void *pa)
 
   r = (struct run*)pa;
 
-  acquire(&kmem.lock);
-  r->next = kmem.freelist;
-  kmem.freelist = r;
-  release(&kmem.lock);
+  //关闭中断
+  push_off();
+  //调用cpuid, 为当前运行的freerange的CPU分配空闲内存
+  int currentCpuId = cpuid();
+  acquire(&kmems[currentCpuId].lock);
+  r->next = kmems[currentCpuId].freelist;
+  kmems[currentCpuId].freelist = r;
+  release(&kmems[currentCpuId].lock);
+  //打开中断
+  pop_off();
 }
 
 // Allocate one 4096-byte page of physical memory.
@@ -69,12 +82,33 @@ void *
 kalloc(void)
 {
   struct run *r;
-
-  acquire(&kmem.lock);
-  r = kmem.freelist;
+  //打开中断
+  push_off();
+  int currentCpuId = cpuid();
+  acquire(&kmems[currentCpuId].lock);
+  r = kmems[currentCpuId].freelist;
   if(r)
-    kmem.freelist = r->next;
-  release(&kmem.lock);
+    kmems[currentCpuId].freelist = r->next;
+  release(&kmems[currentCpuId].lock);
+  
+  //若当前CPU的链表已满，则窃取其他CPU的链表
+  if(!r) {
+    for(int i = 0; i < NCPU; i++) {
+      if(i == currentCpuId)
+        continue;
+      acquire(&kmems[i].lock);
+      r = kmems[i].freelist;
+      if(r) {
+        kmems[i].freelist = r->next;
+        release(&kmems[i].lock);
+        break;
+      }
+      release(&kmems[i].lock);
+    }
+  }
+
+  //打开中断
+  pop_off();
 
   if(r)
     memset((char*)r, 5, PGSIZE); // fill with junk
