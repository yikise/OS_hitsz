diff --git "a/210110612_\347\253\240\346\207\277_\346\223\215\344\275\234\347\263\273\347\273\237\345\256\236\351\252\214\345\233\233\346\212\245\345\221\212.doc" "b/210110612_\347\253\240\346\207\277_\346\223\215\344\275\234\347\263\273\347\273\237\345\256\236\351\252\214\345\233\233\346\212\245\345\221\212.doc"
new file mode 100644
index 0000000..fece971
Binary files /dev/null and "b/210110612_\347\253\240\346\207\277_\346\223\215\344\275\234\347\263\273\347\273\237\345\256\236\351\252\214\345\233\233\346\212\245\345\221\212.doc" differ
diff --git "a/210110612_\347\253\240\346\207\277_\346\223\215\344\275\234\347\263\273\347\273\237\345\256\236\351\252\214\345\233\233\346\212\245\345\221\212.pdf" "b/210110612_\347\253\240\346\207\277_\346\223\215\344\275\234\347\263\273\347\273\237\345\256\236\351\252\214\345\233\233\346\212\245\345\221\212.pdf"
new file mode 100644
index 0000000..159df21
Binary files /dev/null and "b/210110612_\347\253\240\346\207\277_\346\223\215\344\275\234\347\263\273\347\273\237\345\256\236\351\252\214\345\233\233\346\212\245\345\221\212.pdf" differ
diff --git a/grade-lab-pgtbl b/grade-lab-pgtbl
index 0a03209..c56f577 100755
--- a/grade-lab-pgtbl
+++ b/grade-lab-pgtbl
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 
 import re
 from gradelib import *
diff --git a/kernel/defs.h b/kernel/defs.h
index 59f7aae..78aebe4 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -108,6 +108,12 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+// 添加释放进程的内核独立页表的函数
+void            freegrandchildkpgtbl(pagetable_t pagetable);
+void            freechildkpgtbl(pagetable_t pagetable);
+void            freekpgtbl(pagetable_t pagetable);
+// 把进程的用户页表映射到内核页表中的函数
+int             sync_pagetable(pagetable_t, pagetable_t, uint64, uint64);
 
 // swtch.S
 void            swtch(struct context*, struct context*);
@@ -164,6 +170,7 @@ uint64          kvmpa(uint64);
 void            kvmmap(uint64, uint64, uint64, int);
 int             mappages(pagetable_t, uint64, uint64, uint64, int);
 pagetable_t     uvmcreate(void);
+pte_t*          walk(pagetable_t, uint64, int);
 void            uvminit(pagetable_t, uchar *, uint);
 uint64          uvmalloc(pagetable_t, uint64, uint64);
 uint64          uvmdealloc(pagetable_t, uint64, uint64);
@@ -179,6 +186,13 @@ int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
 int             test_pagetable();
+// 添加vmprint的函数
+void            vmprint(pagetable_t);
+void            vmchildprint(pagetable_t, uint64);
+void            vmgrandchildprint(pagetable_t, uint64, uint64);
+// 添加创建内核独立页表的函数
+pagetable_t     kvmsingleinit();
+void            kvmsinglemap(pagetable_t k_pagetable, uint64 va, uint64 pa, uint64 sz, int perm);
 
 // plic.c
 void            plicinit(void);
@@ -224,3 +238,7 @@ int             sockread(struct sock *, uint64, int);
 int             sockwrite(struct sock *, uint64, int);
 void            sockrecvudp(struct mbuf*, uint32, uint16, uint16);
 #endif
+
+//vmcopyin.c
+int             copyin_new(pagetable_t, char *, uint64, uint64);
+int             copyinstr_new(pagetable_t, char *, uint64, uint64);
\ No newline at end of file
diff --git a/kernel/exec.c b/kernel/exec.c
index 7b8a524..bb52239 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -96,7 +96,13 @@ int exec(char *path, char **argv) {
   p->trapframe->epc = elf.entry;  // initial program counter = main
   p->trapframe->sp = sp;          // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
-
+  // 在第一个进程启动时打印页表信息
+  if(p->pid == 1) vmprint(p->pagetable);
+  // 修改独立内核页表
+  //删除旧的映射并将新页面映射到内核页表
+  uvmunmap(p->k_pagetable, 0, PGROUNDUP(oldsz)/PGSIZE, 0);
+  if(sync_pagetable(p->pagetable, p->k_pagetable, 0, p->sz) < 0)
+   goto bad;
   return argc;  // this ends up in a0, the first argument to main(argc, argv)
 
 bad:
diff --git a/kernel/proc.c b/kernel/proc.c
index 292ccb8..269660c 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -35,8 +35,9 @@ void procinit(void) {
     char *pa = kalloc();
     if (pa == 0) panic("kalloc");
     uint64 va = KSTACK((int)(p - proc));
-    kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
-    p->kstack = va;
+    kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W); // 保留内核栈在全局页表kernel_pagetable的映射
+    p->kstack = va; // 在内核页表建立内核栈的映射
+    p->kstack_pa = (uint64)pa; // 把内核栈的物理地址pa拷贝到PCB新增的成员kstack_pa中
   }
   kvminithart();
 }
@@ -77,6 +78,31 @@ int allocpid() {
   return pid;
 }
 
+// 把进程的用户页表映射到内核页表中的函数
+int sync_pagetable(pagetable_t uvm, pagetable_t kvm, uint64 old_sz, uint64 new_sz){
+ pte_t *pte;
+ uint64 pa, i;
+ uint flags;
+ 
+ old_sz = PGROUNDUP(old_sz);
+ if (new_sz <= old_sz) return 0;
+
+ for(i = old_sz; i < new_sz; i += PGSIZE){
+  if((pte = walk(uvm, i, 0)) == 0) //找到PTE的物理地址
+   panic("sync_pagetable: pte should exist");
+  if((*pte & PTE_V) == 0)
+   panic("sync_pagetable: page not present");
+  
+  // 清除PTE_U的标记位
+  pa = PTE2PA(*pte);
+  flags = PTE_FLAGS(*pte);
+  if(mappages(kvm, i, PGSIZE, pa, flags&(~PTE_U)) != 0){ //调用proc_mappages完成映射,并保存相关信息
+   return -1;
+  }
+ }
+ return 0;
+}
+
 // Look in the process table for an UNUSED proc.
 // If found, initialize state required to run in the kernel,
 // and return with p->lock held.
@@ -86,6 +112,7 @@ static struct proc *allocproc(void) {
 
   for (p = proc; p < &proc[NPROC]; p++) {
     acquire(&p->lock);
+
     if (p->state == UNUSED) {
       goto found;
     } else {
@@ -117,12 +144,58 @@ found:
   p->context.ra = (uint64)forkret;
   p->context.sp = p->kstack + PGSIZE;
 
+  // 设置内核页表
+  pagetable_t k_pagetable = kvmsingleinit();
+  
+  // 将内核栈映射到页表k_pagetable中
+  kvmsinglemap(k_pagetable, p->kstack, p->kstack_pa, PGSIZE, PTE_R | PTE_W);
+  p->k_pagetable = k_pagetable;
+
   return p;
 }
 
 // free a proc structure and the data hanging from it,
 // including user pages.
 // p->lock must be held.
+
+void freegrandchildkpgtbl(pagetable_t pagetable) {
+  // 将该叶子页表释放
+  for(int i = 0; i < 512; i++) {
+    pagetable[i] = 0; // 清零
+  }
+  kfree((void*)pagetable); // 释放pagetable指向的物理页
+}
+
+void freechildkpgtbl(pagetable_t pagetable) {
+  for(int i = 0; i < 512; i++) {
+    pte_t pte = pagetable[i]; //获取第i条PTE 
+    if(pte & PTE_V) {
+      /* 判断PTE的Flag位，如果还有下一级页表(即当前是次页表)，
+       则调用释放页表项，并将对应的PTE清零 */
+      // this PTE points to a lower-level page table.
+      uint64 child = PTE2PA(pte); // 将PTE转为为物理地址
+      freegrandchildkpgtbl((pagetable_t)child); // 调用freegrandchildkpgtbl
+    }
+    pagetable[i] = 0; // 清零
+  }
+  kfree((void*)pagetable); // 释放pagetable指向的物理页
+}
+
+void freekpgtbl(pagetable_t pagetable) {
+  for(int i = 0; i < 512; i++) {
+    pte_t pte = pagetable[i]; //获取第i条PTE 
+    if(pte & PTE_V) {
+      /* 判断PTE的Flag位，如果还有下一级页表(即当前是根页表)，
+       则调用释放页表项，并将对应的PTE清零 */
+      // this PTE points to a lower-level page table.
+      uint64 child = PTE2PA(pte); // 将PTE转为为物理地址
+      freechildkpgtbl((pagetable_t)child); // 调用freechildkpgtbl
+    }
+    pagetable[i] = 0; // 清零
+  }
+  kfree((void*)pagetable); // 释放pagetable指向的物理页
+}
+
 static void freeproc(struct proc *p) {
   if (p->trapframe) kfree((void *)p->trapframe);
   p->trapframe = 0;
@@ -136,6 +209,7 @@ static void freeproc(struct proc *p) {
   p->killed = 0;
   p->xstate = 0;
   p->state = UNUSED;
+  freekpgtbl(p->k_pagetable);
 }
 
 // Create a user page table for a given process,
@@ -201,6 +275,9 @@ void userinit(void) {
   p->cwd = namei("/");
 
   p->state = RUNNABLE;
+  //独立内核页表加上用户页表的映射
+  // 包含第一个进程的用户页表
+  sync_pagetable(p->pagetable, p->k_pagetable,0,PGSIZE) ; // 将改变后的进程页表同步到内核页表中。
 
   release(&p->lock);
 }
@@ -216,8 +293,13 @@ int growproc(int n) {
     if ((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
       return -1;
     }
+    // mapper user page to kernel page table
+    if((sync_pagetable(p->pagetable, p->k_pagetable, p->sz, sz)) < 0){
+      return -1;
+    }
   } else if (n < 0) {
     sz = uvmdealloc(p->pagetable, sz, sz + n);
+    uvmunmap(p->k_pagetable,PGROUNDUP(sz),(PGROUNDUP(p->sz)-PGROUNDUP(sz))/PGSIZE,0);
   }
   p->sz = sz;
   return 0;
@@ -262,6 +344,14 @@ int fork(void) {
 
   np->state = RUNNABLE;
 
+  //独立内核页表加上用户页表的映射
+  // 父进程用户空间的页表也全部拷贝一遍给子进程
+  if(sync_pagetable(np->pagetable, np->k_pagetable, 0, np->sz) < 0){
+    freeproc(np);
+    release(&np->lock);
+    return -1;
+  }
+
   release(&np->lock);
 
   return pid;
@@ -430,11 +520,14 @@ void scheduler(void) {
         // before jumping back to us.
         p->state = RUNNING;
         c->proc = p;
+        w_satp(MAKE_SATP(p->k_pagetable));
+        sfence_vma();
         swtch(&c->context, &p->context);
 
         // Process is done running for now.
         // It should have changed its p->state before coming back.
         c->proc = 0;
+        kvminithart();
 
         found = 1;
       }
diff --git a/kernel/proc.h b/kernel/proc.h
index 9c16ea7..d1dfa7e 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -103,4 +103,8 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+  // 给每个进程中设置一个内核独立页表和内核栈的物理地址
+  pagetable_t k_pagetable;
+  uint64 kstack_pa;
 };
diff --git a/kernel/vm.c b/kernel/vm.c
index b794885..4c09d5d 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -45,6 +45,34 @@ void kvminit() {
   kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
 }
 
+pagetable_t kvmsingleinit() {
+  pagetable_t k_pagetable = (pagetable_t)kalloc();
+  memset(k_pagetable, 0, PGSIZE);
+
+  // uart registers
+  kvmsinglemap(k_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+
+  // virtio mmio disk interface
+  kvmsinglemap(k_pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+
+  // 不要映射CLINT，否则会在任务三发生地址重合问题不要映射CLINT，否则会在任务三发生地址重合问题
+
+  // PLIC
+  kvmsinglemap(k_pagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
+
+  // map kernel text executable and read-only.
+  kvmsinglemap(k_pagetable, KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);
+
+  // map kernel data and the physical RAM we'll make use of.
+  kvmsinglemap(k_pagetable, (uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);
+
+  // map the trampoline for trap entry/exit to
+  // the highest virtual address in the kernel.
+  kvmsinglemap(k_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+
+  return k_pagetable;
+}
+
 // Switch h/w page table register to the kernel's page table,
 // and enable paging.
 void kvminithart() {
@@ -104,6 +132,9 @@ void kvmmap(uint64 va, uint64 pa, uint64 sz, int perm) {
   if (mappages(kernel_pagetable, va, sz, pa, perm) != 0) panic("kvmmap");
 }
 
+void kvmsinglemap(pagetable_t k_pagetable, uint64 va, uint64 pa, uint64 sz, int perm) {
+  if (mappages(k_pagetable, va, sz, pa, perm) != 0) panic("kvmsinglemap");
+}
 // translate a kernel virtual address to
 // a physical address. only needed for
 // addresses on the stack.
@@ -316,21 +347,22 @@ int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {
 // Copy len bytes to dst from virtual address srcva in a given page table.
 // Return 0 on success, -1 on error.
 int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
-  uint64 n, va0, pa0;
-
-  while (len > 0) {
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if (pa0 == 0) return -1;
-    n = PGSIZE - (srcva - va0);
-    if (n > len) n = len;
-    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
-
-    len -= n;
-    dst += n;
-    srcva = va0 + PGSIZE;
-  }
-  return 0;
+  return copyin_new(pagetable, dst, srcva, len);
+  // uint64 n, va0, pa0;
+
+  // while (len > 0) {
+  //   va0 = PGROUNDDOWN(srcva);
+  //   pa0 = walkaddr(pagetable, va0);
+  //   if (pa0 == 0) return -1;
+  //   n = PGSIZE - (srcva - va0);
+  //   if (n > len) n = len;
+  //   memmove(dst, (void *)(pa0 + (srcva - va0)), n);
+
+  //   len -= n;
+  //   dst += n;
+  //   srcva = va0 + PGSIZE;
+  // }
+  // return 0;
 }
 
 // Copy a null-terminated string from user to kernel.
@@ -338,38 +370,39 @@ int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
 // until a '\0', or max.
 // Return 0 on success, -1 on error.
 int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max) {
-  uint64 n, va0, pa0;
-  int got_null = 0;
-
-  while (got_null == 0 && max > 0) {
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if (pa0 == 0) return -1;
-    n = PGSIZE - (srcva - va0);
-    if (n > max) n = max;
-
-    char *p = (char *)(pa0 + (srcva - va0));
-    while (n > 0) {
-      if (*p == '\0') {
-        *dst = '\0';
-        got_null = 1;
-        break;
-      } else {
-        *dst = *p;
-      }
-      --n;
-      --max;
-      p++;
-      dst++;
-    }
-
-    srcva = va0 + PGSIZE;
-  }
-  if (got_null) {
-    return 0;
-  } else {
-    return -1;
-  }
+  return copyinstr_new(pagetable, dst, srcva, max);
+  // uint64 n, va0, pa0;
+  // int got_null = 0;
+
+  // while (got_null == 0 && max > 0) {
+  //   va0 = PGROUNDDOWN(srcva);
+  //   pa0 = walkaddr(pagetable, va0);
+  //   if (pa0 == 0) return -1;
+  //   n = PGSIZE - (srcva - va0);
+  //   if (n > max) n = max;
+
+  //   char *p = (char *)(pa0 + (srcva - va0));
+  //   while (n > 0) {
+  //     if (*p == '\0') {
+  //       *dst = '\0';
+  //       got_null = 1;
+  //       break;
+  //     } else {
+  //       *dst = *p;
+  //     }
+  //     --n;
+  //     --max;
+  //     p++;
+  //     dst++;
+  //   }
+
+  //   srcva = va0 + PGSIZE;
+  // }
+  // if (got_null) {
+  //   return 0;
+  // } else {
+  //   return -1;
+  // }
 }
 
 // check if use global kpgtbl or not
@@ -378,4 +411,58 @@ int test_pagetable() {
   uint64 gsatp = MAKE_SATP(kernel_pagetable);
   printf("test_pagetable: %d\n", satp != gsatp);
   return satp != gsatp;
+}
+
+// 加入 页表打印功能
+
+void vmgrandchildprint(pagetable_t pgtbl, uint64 L1, uint64 L2) {
+  // 遍历页表项
+  for(int i = 0; i < 512; i++) {
+    pte_t pte = pgtbl[i]; //获取第i条PTE
+    // /* 判断PTE的Flag位，若虚拟地址有映射到物理地址，则进行打印
+    if(pte & PTE_V){ 
+      // this PTE points to a lower-level page table.
+      uint64 pa = PTE2PA(pte); // 将PTE转为为物理地址
+      uint64 va = (pa & 0xFFF) + (L1 << 30) + (L2 << 21) + (i << 12);
+      printf("||   ||   ||idx: %d: va: %p -> pa: %p, flags: ", i, va, pa);
+      (pte & PTE_R) ? printf("r") : printf("-");
+      (pte & PTE_W) ? printf("w") : printf("-");
+      (pte & PTE_X) ? printf("x") : printf("-");
+      (pte & PTE_U) ? printf("u") : printf("-");
+      printf("\n");
+    }
+  } 
+}
+
+void vmchildprint(pagetable_t pgtbl, uint64 L1) {
+  // 遍历页表项
+ for(int i = 0; i < 512; i++) {
+    pte_t pte = pgtbl[i]; //获取第i条PTE 
+
+    /* 判断PTE的Flag位，如果还有下一级页表(即当前是次页表)，
+       则调用vmgrandchildprint打印 */
+    if(pte & PTE_V){ 
+      // this PTE points to a lower-level page table.
+      uint64 grandchild = PTE2PA(pte); // 将PTE转为为物理地址
+      printf("||   ||idx: %d: pa: %p, flags: ----\n", i, grandchild);
+      vmgrandchildprint((pagetable_t)grandchild, L1, (uint64)i); // 调用vmchildprint
+    }
+  }
+}
+void vmprint(pagetable_t pgtbl) {
+  // 打印 vmprint 的参数，即获得的页表参数具体的值
+  printf("page table %p\n", pgtbl);
+  // 遍历页表项
+  for(int i = 0; i < 512; i++) {
+    pte_t pte = pgtbl[i]; //获取第i条PTE 
+
+    /* 判断PTE的Flag位，如果还有下一级页表(即当前是根页表)，
+       则调用vmchildprint打印 */
+    if(pte & PTE_V){ 
+      // this PTE points to a lower-level page table.
+      uint64 child = PTE2PA(pte); // 将PTE转为为物理地址
+      printf("||idx: %d: pa: %p, flags: ----\n", i, child);
+      vmchildprint((pagetable_t)child, (uint64)i); // 调用vmchildprint
+    }
+  }
 }
\ No newline at end of file
